import "Utils.stg"
AsyncTableSingle(name, keyType, valueType, aggrType, weightType, extraType, expr) ::= <<
package socialite.async.codegen;
<importForDistTable()>

//this is array table
//for dynamic added and pair-key algorithms, hash table is needed
public class DistAsyncTable extends BaseDistAsyncTable {
   <if(IsInt.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <IntegerIdentityElement.(aggrType)>;
    <elseif(IsLong.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <LongIdentityElement.(aggrType)>;
    <elseif(IsFloat.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <FloatIdentityElement.(aggrType)>;
    <elseif(IsDouble.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <DoubleIdentityElement.(aggrType)>;
    <endif>
    private final int workerNum;
    private <KeyIndMap.(keyType)> keyIndMap; <!T<Key>IntHashMap in template!>
    private <IndKeyMap.(keyType)> indKeyMap;
    private <PrimitiveMap.(valueType)> valueList;
    private List\<<TypeAtomicMap.(valueType)>\> deltaList;
    private List\<<PrimitiveMap.(keyType)>\> adjacenciesList;
    <if(weightType)>private List\<<PrimitiveMap.(weightType)>\> weightsList;<endif>
    <if(extraType)>private <PrimitiveMap.(extraType)> extraList;<endif>
    private volatile int size;

    private AtomicIntegerArray messageTableSelector;
    private DistMsgTable[][] messageTableList;
    Map\<Integer, Integer> myIdxWorkerIdMap;
    private int myWorkerId;

    public void setMyIdxWorkerIdMap(Map\<Integer, Integer> myIdxWorkerIdMap) {
        this.myIdxWorkerIdMap = myIdxWorkerIdMap;
    }

    public DistAsyncTable(int workerNum, int myWorkerId, int initSize, int initBufferTableSize) {
        this.workerNum = workerNum;
        this.myWorkerId = myWorkerId;

        keyIndMap = new <KeyIndMap.(keyType)>(initSize);
        indKeyMap = new <IndKeyMap.(keyType)>(initSize);
        deltaList = new ArrayList<>(initSize);
        valueList = new <PrimitiveMap.(valueType)>(initSize);
        adjacenciesList = new ArrayList<>(initSize);

        <if(weightType)>
        weightsList = new <PrimitiveMap.(weightType)>(initSize);
        <endif>
        <if(extraType)>
        extraList = new <PrimitiveMap.(extraType)>(initSize);
        <endif>

        messageTableSelector = new AtomicIntegerArray(workerNum);
        messageTableList = new MessageTable[workerNum][2];
        for (int wid = 0; wid \< workerNum; wid++) {
            if (wid == myWorkerId) continue;//for worker i, it have 0,1,...,i-1,null,i+1,...n-1 buffer table
            messageTableList[wid][0] = new MessageTable(initBufferTableSize);
            messageTableList[wid][1] = new MessageTable(initBufferTableSize);
        }
    }

    public void updateLockFree(int localInd) {
        <valueType> oldDelta = deltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
        if(oldDelta == IDENTITY_ELEMENT)
            return;

        //aggrType: <aggrType> weightType:<weightType> extraType: <extraType>
        <valueType> accumulatedValue = <WrappedTypeMap.(valueType)>.<AggrTypeFuncMap.(aggrType)>(valueList.get(localInd), oldDelta);
        <! 聚集后比原来还小，则不更新 !>
        <if(IsMax.(aggrType))>if(accumulatedValue \<= valueList.get(localInd))return;
        <elseif(IsMin.(aggrType))>if(accumulatedValue >= valueList.get(localInd))return;<endif>

        <!Count函数在不准与extra、weight同用，因为语义不明!>
        <if(!IsCount.(aggrType))>
        <! 有权值 !>
        <if(weightType)><PrimitiveMap.(weightType)> weights = weightsList.get(localInd);<endif>
        <! 有附加值，如图的degree !>
        <if(extraType)><extraType> extra = extraList.get(localInd);<endif>
        <endif>

        <! 遍历每个邻接点 !>
        for(int i = 0; i \< adjacenciesList.size(); i++){
            <KeyTypeMap.(keyType)> adjacency = adjacenciesList.get(i); //key for adjacent node

            <if(!IsCount.(aggrType))>
            <if(weightType)><weightType> weight = weights.get(i);<endif>
            <valueType> newDelta = eval(weight, oldDelta);
            <endif>

            int belongToWorkerId = getWorkerId(adjacency);
            //on local machine
            if (belongToWorkerId == myWorkerId) {
                int adjacentLocalInd = keyIndMap.get(adjacency);
                <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max)<endif>
                <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min)<endif>
                <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta, 1)<endif>
            } else {
                MessageTable msgTable = messageTableList[belongToWorkerId][messageTableSelector.get(belongToWorkerId)];
                msgTable.apply(adjacency, newDelta);
            }
        }
    }

    /**
     * 将远程Worker发来的Buffer累积到本地DistAsyncTable
     *
     * @param messageTable 远程BufferTable
     */
    @Override
    public void applyBuffer(MessageTable messageTable) {
        messageTable.getKeyDeltaMap().forEach((key, delta) -> {
            int localInd = keyIndMap.get(key);
                                                                    <!Integer/Double          :: sum/max/min!>
            deltaList.get(localInd).accumulateAndGet(delta.get(), <WrappedTypeMap.(valueType)>::<AggrTypeFuncMap.(aggrType)>);
        });
    }

    private int tableId;

    public void setTableId(int tableId) {
        this.tableId = tableId;
    }

    // should same as InitCarrier.getWorkerId
    public int getWorkerId(int key, int workerNum) {
        int myIdx = sliceMap.machineIndexFor(tableId, key);
        return myIdxWorkerIdMap.get(myIdx);
    }

    @Override
    public Object getValue() {
        return valueList;
    }

    @Override
    public double accumulateValue() {
        double sum = 0;
        for (int i = 0; i \< size; i++) {
            sum += valueList.get(i);
        }
        return sum;
    }

    private double eval(int weight, int extra, double oldDelta) {
        return (<valueType>)(<expr>);
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public void iterate(MyVisitorImpl visitor) {
        keyIndMap.forEachEntry((key, ind) -> visitor.visit(key, valueList.get(ind), deltaList.get(ind).doubleValue())
        );
    }

    //for dynamically algorithms
    public synchronized void addEntryDynamically(int key, int value, int delta, int extra) {

    }

    @Override
    public AtomicIntegerArray getMessageTableSelector() {
        return messageTableSelector;
    }

    @Override
    public MessageTable[] getMessageAndBackup(int workerId) {
        return messageTableList[workerId];
    }

    private static final Log L = LogFactory.getLog(DistAsyncTable.class);

    /*
    public void display() {
        L.info("ind\tkey\tvalue\tDvalue\tadjacent\textra");
        keyIndMap.forEachEntry((key, ind) -> {
            double value = valueList.get(ind);
            double dValue = deltaList.get(ind).doubleValue();
            TIntList adjacents = dataList.get(ind);

            L.info(String.format("%d\t\t%d\t%f\t%f\t%s\t%d", ind, key, value, dValue, Arrays.toString(adjacents.toArray()), extra.get(ind)));
            return true;
        });
    }
    */

    DistTableSliceMap sliceMap;

    public void setSliceMap(DistTableSliceMap sliceMap) {
        this.sliceMap = sliceMap;
    }

    public MyVisitorImpl getMiddleVisitor() {
        return new MyVisitorImpl() {
            TIntArrayList adjacents;

            //"Middle(int Key:0..875713, double initD, int degree, (int adj))."
            @Override
            public boolean visit_0_1_2(int a1, double a2, int a3) {
                keyIndMap.put(a1, size++);
                valueList.add(IDENTITY_ELEMENT);
                deltaList.add(new MyAtomicDouble(a2));
                extra.add(a3);
                adjacents = new TIntArrayList();
                dataList.add(adjacents);
                return true;
            }

            @Override
            public boolean visit(int a1) {
                adjacents.add(a1);
                return true;
            }
        };
    }

    public static class MessageTable {
        <! keyType should be int\long\key !>
        private Map\<<WrappedTypeMap.(keyType)>, <TypeAtomicMap.(valueType)>\> keyDeltaMap;
        private transient MyAtomicInteger updateCounter;

        private MessageTable(){
            //constructor for kryo
        }

        public MessageTable(int initSize) {
            updateCounter = new MyAtomicInteger(0);
            keyDeltaMap = new ConcurrentHashMap<>(initSize);
        }


        /**
         * 累积delta值
         *
         * @param key   全局索引
         * @param delta delta value
         */
        public void apply(<WrappedTypeMap.(keyType)> key, <valueType> delta) {
            <TypeAtomicMap.(valueType)> atomicDelta = keyDeltaMap.putIfAbsent(key, new <TypeAtomicMap.(valueType)>(delta));
            if (atomicDelta != null) {
                atomicDelta.accumulateAndGet(delta, <WrappedTypeMap.(valueType)>::<AggrTypeFuncMap.(aggrType)>);
            }
            updateCounter.addAndGet(1);
        }

        public int getUpdateTimes() {
            return updateCounter.intValue();
        }

        public void resetDelta() {
            keyDeltaMap.values().forEach(delta -> delta.set(DistAsyncTable.IDENTITY_ELEMENT));
            updateCounter.set(0);
        }

        public Map\<<WrappedTypeMap.(keyType)> key, <TypeAtomicMap.(valueType)>\> getKeyDeltaMap() {
            return keyDeltaMap;
        }
    }
}
>>