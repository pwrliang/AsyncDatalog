import "Utils.stg"
AsyncTableSingle(name, valueType, aggrType,
           edgeIsNested, srcV, dstV, weightV,
           extraV, expr) ::= <<
package socialite.async.codegen;
<importForTable()>

public class <name> extends BaseAsyncTable{
    private static final Log L = LogFactory.getLog(<name>.class);
    //private <PrimitiveMap.(srcV.type)> srcArr;
    private <PrimitiveMap.(valueType)> value;
    private List\<<TypeAtomicMap.(valueType)>\> deltaValue;
    <if(IsFloat.(weightV.type))>
    Assert.not_supported("float is not supported");
    <else>
    private List\<<PrimitiveMap.(dstV.type)>\> dstList;
    <endif>

    <! for PageRank !>
    <if(extraV)>
    private <PrimitiveMap.(extraV.type)> extra;
    <endif>

    <if(IsInt.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <IntegerIdentityElement.(aggrType)>;
    <elseif(IsLong.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <LongIdentityElement.(aggrType)>;
    <elseif(IsFloat.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <FloatIdentityElement.(aggrType)>;
    <elseif(IsDouble.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <DoubleIdentityElement.(aggrType)>;
    <endif>

    private int size;

    public <name>(int initSize){
       //srcArr = new <PrimitiveMap.(srcV.type)>(initSize);
       value = new <PrimitiveMap.(valueType)>(initSize);
       deltaValue = new ArrayList\<>(initSize);
       dstList = new ArrayList\<>(initSize);
       <if(extraV)>
       extra = new <PrimitiveMap.(extraV.type)>(initSize);
       <endif>
    }

    @Override
    public void updateLockFree(int k) {
        <valueType> oldDelta = deltaValue.get(k).getAndSet(IDENTITY_ELEMENT);
        if (oldDelta == IDENTITY_ELEMENT)
            return;

        <! 对于带权图的更新 !>
        <if(weightV)>
        <!判定聚集函数类型!>
        <if(IsSum.(aggrType))>
        //weight sum
        value.set(k, value.get(k) + oldDelta);
        <PrimitiveMap.(dstV.type)> dstWeight = dstList.get(k);
        for(int i = 0; i \< dstWeight.size() - 1; i+=2){
            <dstV.type> dst = dstWeight.get(i);
            <weightV.type> weight = dstWeight.get(i+1);
            <valueType> newDelta = eval(k, weight, oldDelta);
            deltaValue.get(dst).addAndGet(newDelta);
        }
        <elseif(IsMax.(aggrType))>
        //weight max
        <valueType> tmp = Math.max(value.get(k), oldDelta);
        if(tmp > value.get(k)){
            value.set(k, tmp);
            <PrimitiveMap.(dstV.type)> dstWeight = dstList.get(k);
            for(int i = 0; i \< dstWeight.size() - 1; i+=2){
                <dstV.type> dst = dstWeight.get(i);
                <weightV.type> weight = dstWeight.get(i+1);
                <valueType> newDelta = eval(k, weight, oldDelta);
                deltaValue.get(dst).accumulateAndGet(newDelta, Math::max);
            }
        }
        <elseif(IsMin.(aggrType))>
        //weight min
          <valueType> tmp = Math.min(value.get(k), oldDelta);
            if(tmp \< value.get(k)){
                value.set(k, tmp);
                <PrimitiveMap.(dstV.type)> dstWeight = dstList.get(k);
                for(int i = 0; i \< dstWeight.size() - 1; i+=2){
                    <dstV.type> dst = dstWeight.get(i);
                    <weightV.type> weight = dstWeight.get(i+1);
                    <valueType> newDelta = eval(k, weight, oldDelta);
                    deltaValue.get(dst).accumulateAndGet(newDelta, Math::min);
                }
            }
        <elseif(IsCount.(aggrType))>
        //weight count
        value.set(k, value.get(k) + oldDelta);
        //int[] dstWeight = dstList.get(k);
        for(int i = 0; i \< dstWeight.size() - 1; i+=2){
            //<valueType> newDelta = eval(k, dstWeight[i], oldDelta);
            deltaValue.get(dst).addAndGet(1);
        }
        <endif><!判定聚集函数类型结束!>
        <! 对于无权图的更新 !>
        <else>
        <if(IsSum.(aggrType))>
        //non-weight sum
        value.set(k, value.get(k) + oldDelta);
        <PrimitiveMap.(dstV.type)> dstArr = dstList.get(k);
        for(int i = 0; i \< dstArr.size(); i++){
            <dstV.type> dst = dstArr.get(i);
            <valueType> newDelta = eval(k, 0, oldDelta);
            deltaValue.get(dst).addAndGet(newDelta);
        }
        <elseif(IsMax.(aggrType))>
        //non-weight max
        <valueType> tmp = Math.max(value.get(k), oldDelta);
        if(tmp > value.get(k)){
            value.set(k, tmp);
            <PrimitiveMap.(dstV.type)> dstArr = dstList.get(k);
            for(int i = 0; i \< dstArr.size(); i++){
                <dstV.type> dst = dstArr.get(i);
                <valueType> newDelta = eval(k, 0, oldDelta);
                deltaValue.get(dst).accumulateAndGet(newDelta, Math::max);
            }
        }
        <elseif(IsMin.(aggrType))>
        //non-weight min
        <valueType> tmp = Math.min(value.get(k), oldDelta);
        if(tmp \< value.get(k)){
            value.set(k, tmp);
            <PrimitiveMap.(dstV.type)> dstArr = dstList.get(k);
            for(int i = 0; i \< dstArr.size(); i++){
                <dstV.type> dst = dstArr.get(i);
                <valueType> newDelta = eval(k, 0, oldDelta);
                deltaValue.get(dst).accumulateAndGet(newDelta, Math::min);
            }
        }
        <elseif(IsCount.(aggrType))>
        //non-weight count
        value.set(k, value.get(k) + oldDelta);
        <srcV.type>[] dstArr = dstList.get(k);
        for(int i = 0; i \< dstArr.length; i++){
            deltaValue.get(dst).addAndGet(1);
        }
        <endif>
        <endif>
    }

    private <valueType> eval(<srcV.type> src, <weightV.type> weight, <valueType> oldDelta){
        //0.8*oldDelta/extra.get(src)
        return (<valueType>) (<expr>);
    }

    @Override
    public <PrimitiveMap.(valueType)> getValue(){
        return value;
    }

    @Override
    public MyVisitorImpl getEdgeVisitor() {
        return new MyVisitorImpl() {
            <if(edgeIsNested)>
            <srcV.type> <srcV.name>;
            <endif>

            @Override
            <! 嵌套列 !>
            <if(edgeIsNested)>
            public boolean visit_0(<srcV.type> <srcV.name>) {
                this.<srcV.name> = <srcV.name>;
                return true;
            }
            <! 带权重 !>
            <if(weightV)>
            //nested weight
            public boolean visit(<dstV.type> <dstV.name>, <weightV.type> <weightV.name>) {
                <PrimitiveMap.(dstV.type)> dstWeight = dstList.get(<srcV.name>);
                dstWeight.add(<dstV.name>);
                dstWeight.add(<weightV.name>);
                return true;
            }
            <else>
            //nested non-weight
            public boolean visit(<dstV.type> <dstV.name>) {
                <PrimitiveMap.(dstV.type)> dstWeight = dstList.get(<srcV.name>);
                dstWeight.add(<dstV.name>);
                return true;
            }
            <endif>
            <else><! 非嵌套 !>
            <if(weightV)>
            //non-nested weight
            public boolean visit(<srcV.type> <srcV.name>, <dstV.type> <dstV.name>, <weightV.type> <weightV.name>) {
                Assert.not_supported();
                return true;
            }
            <else>
            //non-nested non-weight
            public boolean visit(<srcV.type> <srcV.name>, <dstV.type> <dstV.name>) {
                Assert.not_supported();
                return true;
            }
            <endif>
            <endif>
        };
    }

    @Override
    public MyVisitorImpl getExtraVisitor(){
        <if(extraV)>
        return new MyVisitorImpl() {
            @Override
            public boolean visit(<srcV.type> a1, <extraV.type> a2) {
                extra.add(a2);
                return true;
            }
        };
        <else>
        return null;
        <endif>
    }

    @Override
    public MyVisitorImpl getInitVisitor(){
        return new MyVisitorImpl(){
            @Override
            public boolean visit(<srcV.type> a1, <valueType> a2) {
                //srcArr.add(a1);
                dstList.add(new <PrimitiveMap.(dstV.type)>());
                <! 初始化Value !>
                <if(IsInt.(valueType))>
                value.add(<IntegerIdentityElement.(aggrType)>);
                <elseif(IsLong.(valueType))>
                value.add(<LongIdentityElement.(aggrType)>);
                <elseif(IsFloat.(valueType))>
                value.add(<FloatIdentityElement.(aggrType)>);
                <elseif(IsDouble.(valueType))>
                value.add(<DoubleIdentityElement.(aggrType)>);
                <endif><! 初始化Value !>
                deltaValue.add(new <TypeAtomicMap.(valueType)>(a2));
                size++;
                return true;
            }
        };
    }

    @Override
	public void iterate(MyVisitorImpl visitor) {
		for (int i=0; i\<value.size(); i++) {
		    if (!visitor.visit(i, value.get(i)))
		        break;
		}
	}

    @Override
    public int getSize(){
        return size;
    }
}
>>