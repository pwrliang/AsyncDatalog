import "Utils.stg"
AsyncTableSingle(name, keyType, valueType, deltaType, aggrType, weightType, extraType, expr) ::= <<
package socialite.async.codegen;
<importForTable()>
//algorithm <name>
public class AsyncTable extends BaseAsyncTable{
    private static final Log L = LogFactory.getLog(AsyncTable.class);
    <if(IsBoolean.(valueType))>private <KeyIndMap.(keyType)> keyIndMap;
    <!when key is int or long, use key as index!>
    <elseif(!IsKeyAsIndex.(keyType))>private <KeyIndMap.(keyType)> keyIndMap;<endif>

    <if(IsBoolean.(valueType))>
        private <IndKeyMap.(keyType)> indKeyMap;
        private <PrimitiveObjectMap.(keyType)>\<<PrimitiveMap.(keyType)>\> col1KeysMap;
    <elseif(IsPairKey.(keyType))>
        private TIntObjectHashMap\<Pair> indKeyMap;//动态添加做连接用
        private TIntObjectHashMap\<List\<Pair\>> col1KeysMap;
    <endif>

    private <PrimitiveMap.(valueType)> valueList;
    private List\<<TypeAtomicMap.(deltaType)>\> deltaList;
    private List\<<PrimitiveMap.(keyType)>\> adjacenciesList; //除了key为int类型的装ind，该字段装邻接点数据
    <!optional dependent on algorithms!>
    <if(weightType)>private List\<<PrimitiveMap.(weightType)>\> weightsList;<endif>
    <if(extraType)>private <PrimitiveMap.(extraType)> extraList;<endif>
    <if(IsBoolean.(valueType))>private List\<Boolean> sentFlagList;<endif>


    <if(IsInt.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <IntegerIdentityElement.(aggrType)>;
    <elseif(IsLong.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <LongIdentityElement.(aggrType)>;
    <elseif(IsFloat.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <FloatIdentityElement.(aggrType)>;
    <elseif(IsDouble.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <DoubleIdentityElement.(aggrType)>;
    <endif>

    private int size;

    public AsyncTable(int initSize){
       <if(IsBoolean.(valueType))>keyIndMap = new <KeyIndMap.(keyType)>(size);
       <elseif(!IsKeyAsIndex.(keyType))> keyIndMap = new <KeyIndMap.(keyType)>(size);<endif>

       <if(IsBoolean.(valueType))>
            indKeyMap = new <IndKeyMap.(keyType)>(size);
            col1KeysMap = new <PrimitiveObjectMap.(keyType)>\<<PrimitiveMap.(keyType)>\>(size);
       <elseif(IsPairKey.(keyType))>
            indKeyMap = new TIntObjectHashMap\<>(size);
            col1KeysMap = new TIntObjectHashMap\<>(size);
       <endif>

       valueList = new <PrimitiveMap.(valueType)>(initSize);
       deltaList = new ArrayList\<>(initSize);
       adjacenciesList = new ArrayList\<>(size);
       <if(weightType)> weightsList = new ArrayList\<>(size);<endif>
       <if(extraType)> extraList = new <PrimitiveMap.(extraType)>(size);<endif>
       <if(IsBoolean.(valueType))>sentFlagList = new ArrayList\<>();<endif>
    }

    @Override
    public void updateLockFree(int localInd) {
        <if(IsBoolean.(valueType))>
            if (sentFlagList.get(localInd)) return;
            <deltaType> oldDelta = deltaList.get(localInd).get();
            if (eval(oldDelta))
                valueList.set(localInd, true);
            if (!valueList.get(localInd))
                return;
            <PrimitiveMap.(keyType)> adjacencies = adjacenciesList.get(localInd);
            <! 遍历每个邻接点 !>
            for(int i = 0; i \< adjacencies.size(); i++){
                int adjacentLocalInd;
                <keyType> adjacency = adjacencies.get(i);
                <!when use int as key, use key as index!>
                if(keyIndMap.contains(adjacency))
                    adjacentLocalInd = keyIndMap.get(adjacency);
                else {
                    adjacentLocalInd = addEntry(adjacency);
                }
                <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
                <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
                <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
            }
            sentFlagList.set(localInd, true);
        <else>
            <deltaType> oldDelta = deltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
            if(oldDelta == IDENTITY_ELEMENT)
                return;

            //keyType: <keyType> aggrType: <aggrType> weightType:<weightType> extraType: <extraType>
            <valueType> accumulatedValue = <WrappedTypeMap.(valueType)>.<AggrTypeFuncMap.(aggrType)>(valueList.get(localInd), oldDelta);
            <! 聚集后比原来还小，则不更新 !>
            <if(IsMax.(aggrType))>if(accumulatedValue \<= valueList.get(localInd))return;
            <elseif(IsMin.(aggrType))>if(accumulatedValue >= valueList.get(localInd))return;<endif>
            //更新value
            valueList.set(localInd, accumulatedValue);
            <!Count函数在不准与extra、weight同用，因为语义不明!>
            <if(!IsCount.(aggrType))>
                <! 有权值 !>
                <if(weightType)><PrimitiveMap.(weightType)> weights = weightsList.get(localInd);<endif>
                <! 有附加值，如图的degree !>
                <if(extraType)><extraType> extra = extraList.get(localInd);<endif>
            <endif>

            <PrimitiveMap.(keyType)> adjacencies = adjacenciesList.get(localInd);
            <! 遍历每个邻接点 !>
            for(int i = 0; i \< adjacencies.size(); i++){
                <if(!IsCount.(aggrType))>
                <valueType> newDelta = eval(oldDelta <if(weightType)>, weights.get(i)<endif> <if(extraType)>, extra<endif>);
                <endif>
                <!when use int as key, use key as index!>
                <if(IsKeyAsIndex.(keyType))>
                    int adjacentLocalInd = adjacencies.get(i);
                <else>
                    <if(IsPairKey.(keyType))>
                        int adjacentLocalInd;
                        Pair adjacency = adjacencies.get(i);
                        if(keyIndMap.contains(adjacency))
                            adjacentLocalInd = keyIndMap.get(adjacency);
                        else{
                            Pair key = indKeyMap.get(localInd);
                            adjacentLocalInd = addEntry(key.v0, adjacency.v1);
                        }
                    <else>
                        int adjacentLocalInd = keyIndMap.get(adjacencies.get(i)); //key for adjacent node
                    <endif>
                <endif>
                <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
                <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
                <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
            }
        <endif>
    }

    <if(IsBoolean.(valueType))>
    private boolean eval(<deltaType> oldDelta) {
        return (<expr>);
    }
    <else>
    private <deltaType> eval(<deltaType> oldDelta <if(weightType)>,<weightType> weight<endif> <if(extraType)>, <extraType> extra<endif>) {
        return (<deltaType>)(<expr>);
    }
    <endif>

    <if(IsPairKey.(keyType))>
    private synchronized int addEntry(int col1OfKey, int col2OfKey){
        Pair key = new Pair(col1OfKey, col2OfKey);
        keyIndMap.put(key, size);
        indKeyMap.put(size, key);
        valueList.add(IDENTITY_ELEMENT);
        deltaList.add(new <TypeAtomicMap.(deltaType)>(IDENTITY_ELEMENT));
        adjacenciesList.add(new <PrimitiveMap.(keyType)>(col1KeysMap.get(col2OfKey)));
        return size++;
    }
    <elseif(IsBoolean.(valueType))>
    private synchronized int addEntry(<keyType> key){
        keyIndMap.put(key, size);
        indKeyMap.put(size, key);
        valueList.add(false);
        deltaList.add(new <TypeAtomicMap.(deltaType)>(IDENTITY_ELEMENT));
        adjacenciesList.add(new <PrimitiveMap.(keyType)>(col1KeysMap.get(key)));
        sentFlagList.add(false);
        return size++;
    }
    <endif>

    @Override
    public MyVisitorImpl getInitVisitor(){
        return new MyVisitorImpl(){
            <PrimitiveMap.(keyType)> adjacencies;
            <! Pair类型的Key!>
            <if(IsPairKey.(keyType))>
                int col1OfKey;
                @Override
                public boolean visit_0_1_2(int col1OfKey, int col2OfKey, <valueType> delta){
                    this.col1OfKey = col1OfKey;
                    Pair key = new Pair(col1OfKey, col2OfKey);
                    keyIndMap.put(key, size);
                    indKeyMap.put(size, key);
                    <!按照第一列建立索引!>
                    List\<Pair> keys = col1KeysMap.get(col1OfKey);
                    if(keys == null){
                        keys = new ArrayList\<>();
                        col1KeysMap.put(col1OfKey, keys);
                    }
                    keys.add(key);
                    <!按照第一列建立索引!>
                    valueList.add(IDENTITY_ELEMENT);
                    deltaList.add(new <TypeAtomicMap.(valueType)>(delta));
                    adjacencies = new <PrimitiveMap.(keyType)>();
                    adjacenciesList.add(adjacencies);
                    size++;
                    return true;
                }

                @Override
                public boolean visit(int col2OfAdjacency){
                    adjacencies.add(new Pair(col1OfKey, col2OfAdjacency));
                    return true;
                }
            <elseif(IsBoolean.(valueType))>
                @Override
                public boolean visit_0(<keyType> key){
                    keyIndMap.put(key, size);
                    indKeyMap.put(size, key);
                    valueList.add(true);
                    deltaList.add(new <TypeAtomicMap.(deltaType)>(IDENTITY_ELEMENT));
                    adjacencies = new <PrimitiveMap.(keyType)>();
                    adjacenciesList.add(adjacencies);
                    sentFlagList.add(false);
                    size++;
                    return true;
                }

                @Override
                public boolean visit(<keyType> adjacency){
                    adjacencies.add(adjacency);
                    return true;
                }
            <else>
                <if(weightType)><PrimitiveMap.(weightType)> weights;<endif>
                @Override
                public boolean visit_0_1<if(extraType)>_2<endif>(<keyType> key, <deltaType> delta <if(extraType)>, <extraType> extra<endif>){
                    <if(!IsKeyAsIndex)>keyIndMap.put(key, size)<endif>
                    valueList.add(IDENTITY_ELEMENT);
                    deltaList.add(new <TypeAtomicMap.(deltaType)>(delta));
                    adjacencies = new <PrimitiveMap.(keyType)>();
                    adjacenciesList.add(adjacencies);
                    <if(extraType)>extraList.add(extra);<endif>
                    <if(weightType)>
                    weights = new <PrimitiveMap.(weightType)>();
                    weightsList.add(weights);
                    <endif>
                    size++;
                    return true;
                }

                @Override
                public boolean visit(<keyType> adjacency <if(weightType)>, <weightType> weight<endif>){
                    adjacencies.add(adjacency);
                    <if(weightType)>weights.add(weight);<endif>
                    return true;
                }
            <endif>
        };
    }

    <if(IsBoolean.(valueType))>
    public MyVisitorImpl getEdgeVisitor(){
        return new MyVisitorImpl() {
            <PrimitiveMap.(keyType)> keys;

            @Override
            public boolean visit_0(<keyType> key) {
                <!按照第一列建立索引!>
                keys = col1KeysMap.get(key);
                if(keys == null){
                    keys = new <PrimitiveMap.(keyType)>();
                    col1KeysMap.put(key, keys);
                }
                <!按照第一列建立索引!>
                return true;
            }

            @Override
            public boolean visit(<keyType> key) {
                keys.add(key);
                return true;
            }
        };
    }
    <endif>

    @Override
    <if(IsBoolean.(valueType))>
    public Integer accumulateValue(){
        int sum = 0;
        for(int i=0;i\<size;i++)
            if(valueList.get(i))
                sum++;
        return sum;
    }
    <else>
    public <WrappedTypeMap.(deltaType)> accumulateValue(){
        <valueType> sum = 0;
        for(int i=0;i\<size;i++) sum+=valueList.get(i);
        return sum;
    }
    <endif>

    @Override
    public <WrappedTypeMap.(deltaType)> accumulateDelta(){
        <deltaType> sum = 0;
        for(int i=0;i\<size;i++) sum+=deltaList.get(i).<deltaType>Value();
        return sum;
    }

    @Override
	public void iterate(MyVisitorImpl visitor) {
		for (int i=0; i\<size; i++) {
		    <if(IsPairKey.(keyType))>
                Pair pair = indKeyMap.get(i);
                if (!visitor.visit(pair.toString(), valueList.get(i), deltaList.get(i).<deltaType>Value()))
                    break;
            <elseif(IsBoolean.(valueType))>
                if(valueList.get(i))
                    if (!visitor.visit(indKeyMap.get(i)))
                        break;
            <elseif(IsKeyAsIndex.(keyType))>
                if (!visitor.visit(i, valueList.get(i), deltaList.get(i).<deltaType>Value()))
                    break;
            <else>
                if(!visitor.visit(indKeyMap.get(i), valueList.get(i), deltaList.get(i).<deltaType>Value()))
                    break;
		    <endif>
		}
	}

    @Override
    public int getSize(){
        return size;
    }

    <if(IsPairKey.(keyType))>
    private class Pair {
        final int v0;
        final int v1;
        private int hashCode = -1;

        Pair(int v0, int v1) {
            this.v0 = v0;
            this.v1 = v1;
        }

        @Override
        public String toString() {
            return v0 + " " + v1;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Key key = (Key) o;

            if (v0 != key.v0) return false;
            return v1 == key.v1;
        }

        @Override
        public int hashCode() {
            if (hashCode != -1)
                return hashCode;
            hashCode = v0;
            hashCode = 31 * hashCode + v1;
            return hashCode;
        }
    }
    <endif>
}
>>