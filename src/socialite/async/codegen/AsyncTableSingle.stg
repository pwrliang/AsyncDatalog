import "Utils.stg"
AsyncTableSingle(name, keyType, valueType, aggrType, weightType, extraType, expr) ::= <<
package socialite.async.codegen;
<importForTable()>
//algorithm <name>
public class AsyncTable extends BaseAsyncTable{
    private static final Log L = LogFactory.getLog(AsyncTable.class);
    <!when key is int or long, use key as index!>
    <if(!IsKeyAsIndex.(keyType))>private <KeyIndMap.(keyType)> keyIndMap;<endif>
    <if(IsPairKey.(keyType))>
        private TIntObjectHashMap\<Pair> indKeyMap;
        private TIntObjectHashMap\<List\<Pair\>> col1KeysMap;
    <endif>

    private <PrimitiveMap.(valueType)> valueList;
    private List\<<TypeAtomicMap.(valueType)>\> deltaList;
    private List\<<PrimitiveMap.(keyType)>\> adjacenciesList; //除了key为int类型的装ind，该字段装邻接点数据
    <!optional dependent on algorithms!>
    <if(weightType)>private List\<<PrimitiveMap.(weightType)>\> weightsList;<endif>
    <if(extraType)>private <PrimitiveMap.(extraType)> extraList;<endif>



    <if(IsInt.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <IntegerIdentityElement.(aggrType)>;
    <elseif(IsLong.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <LongIdentityElement.(aggrType)>;
    <elseif(IsFloat.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <FloatIdentityElement.(aggrType)>;
    <elseif(IsDouble.(valueType))>
    public static final <valueType> IDENTITY_ELEMENT = <DoubleIdentityElement.(aggrType)>;
    <endif>

    private int size;

    public AsyncTable(int initSize){
       <if(!IsKeyAsIndex.(keyType))> keyIndMap = new <KeyIndMap.(keyType)>(size);<endif>
       <if(IsPairKey.(keyType))>
       indKeyMap = new TIntObjectHashMap\<>(size);
       col1KeysMap = new TIntObjectHashMap\<>(size);
       <endif>
       valueList = new <PrimitiveMap.(valueType)>(initSize);
       deltaList = new ArrayList\<>(initSize);
       adjacenciesList = new ArrayList\<>(size);
       <if(weightType)> weightsList = new ArrayList\<>(size);<endif>
       <if(extraType)> extraList = new <PrimitiveMap.(extraType)>(size);<endif>
    }

    @Override
    public void updateLockFree(int localInd) {
        <valueType> oldDelta = deltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
        if(oldDelta == IDENTITY_ELEMENT)
            return;

        //keyType: <keyType> aggrType: <aggrType> weightType:<weightType> extraType: <extraType>
        <valueType> accumulatedValue = <WrappedTypeMap.(valueType)>.<AggrTypeFuncMap.(aggrType)>(valueList.get(localInd), oldDelta);
        <! 聚集后比原来还小，则不更新 !>
        <if(IsMax.(aggrType))>if(accumulatedValue \<= valueList.get(localInd))return;
        <elseif(IsMin.(aggrType))>if(accumulatedValue >= valueList.get(localInd))return;<endif>

        <!Count函数在不准与extra、weight同用，因为语义不明!>
        <if(!IsCount.(aggrType))>
        <! 有权值 !>
        <if(weightType)><PrimitiveMap.(weightType)> weights = weightsList.get(localInd);<endif>
        <! 有附加值，如图的degree !>
        <if(extraType)><extraType> extra = extraList.get(localInd);<endif>
        <endif>

        <PrimitiveMap.(keyType)> adjacencies = adjacenciesList.get(localInd);
        <! 遍历每个邻接点 !>
        for(int i = 0; i \< adjacencies.size(); i++){
            <if(!IsCount.(aggrType))>
            <valueType> newDelta = eval(oldDelta <if(weightType)>, weights.get(i)<endif> <if(extraType)>, extra<endif>);
            <endif>
            <!when use int as key, use key as index!>
            <if(IsKeyAsIndex.(keyType))>
            int adjacentLocalInd = adjacencies.get(i);
            <else>
                <if(IsPairKey.(keyType))>
                    int adjacentLocalInd;
                    Pair adjacency = adjacencies.get(i);
                    if(keyIndMap.contains(adjacency))
                        adjacentLocalInd = keyIndMap.get(adjacency);
                    else{
                        Pair key = indKeyMap.get(localInd);
                        adjacentLocalInd = addEntry(key.v0, adjacency.v1);
                    }
                <else>
                    int adjacentLocalInd = keyIndMap.get(adjacencies.get(i)); //key for adjacent node
                <endif>
            <endif>
            <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
            <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
            <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
            <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
        }
    }

    private <valueType> eval(<valueType> oldDelta <if(weightType)>,<weightType> weight<endif> <if(extraType)>, <extraType> extra<endif>) {
        return (<valueType>)(<expr>);
    }

    <if(IsPairKey.(keyType))>
    private synchronized int addEntry(int col1OfKey, int col2OfKey){
        Pair key = new Pair(col1OfKey, col2OfKey);
        keyIndMap.put(key, size);
        indKeyMap.put(size, key);
        deltaList.add(new <TypeAtomicMap.(valueType)>(IDENTITY_ELEMENT));
        adjacenciesList.add(new <PrimitiveMap.(keyType)>(col1KeysMap.get(col2OfKey)));
        return size++;
    }
    <endif>

    @Override
    public MyVisitorImpl getInitVisitor(){
        return new MyVisitorImpl(){
            <PrimitiveMap.(keyType)> adjacencies;
            <! Pair类型的Key!>
            <if(IsPairKey.(keyType))>
            int col1OfKey;
            @Override
            public boolean visit_0_1_2(int col1OfKey, int col2OfKey, <valueType> delta){
                this.col1OfKey = col1OfKey;
                Pair key = new Pair(col1OfKey, col2OfKey);
                keyIndMap.put(key, size);
                indKeyMap.put(size, key);
                <!按照第一列建立索引!>
                List\<Pair> keys = col1KeysMap.get(col1OfKey);
                if(keys == null){
                    keys = new ArrayList\<>();
                    col1KeysMap.put(col1OfKey, keys);
                }
                keys.add(key);
                <!按照第一列建立索引!>
                valueList.add(IDENTITY_ELEMENT);
                deltaList.add(new <TypeAtomicMap.(valueType)>(delta));
                adjacencies = new <PrimitiveMap.(keyType)>();
                adjacenciesList.add(adjacencies);
                size++;
                return true;
            }

            @Override
            public boolean visit(int col2OfAdjacency){
                adjacencies.add(new Pair(col1OfKey, col2OfAdjacency));
                return true;
            }
            <else>
            <if(weightType)><PrimitiveMap.(weightType)> weights;<endif>
            @Override
            public boolean visit_0_1<if(extraType)>_2<endif>(<keyType> key, <valueType> delta <if(extraType)>, <extraType> extra<endif>){
                <if(!IsKeyAsIndex)>keyIndMap.put(key, size)<endif>
                valueList.add(IDENTITY_ELEMENT);
                deltaList.add(new <TypeAtomicMap.(valueType)>(delta));
                adjacencies = new <PrimitiveMap.(keyType)>();
                adjacenciesList.add(adjacencies);
                <if(extraType)>extraList.add(extra);<endif>
                <if(weightType)>
                weights = new <PrimitiveMap.(weightType)>();
                weightsList.add(weights);
                <endif>
                size++;
                return true;
            }

            @Override
            public boolean visit(<keyType> adjacency <if(weightType)>, <weightType> weight<endif>){
                adjacencies.add(adjacency);
                <if(weightType)>weights.add(weight);<endif>
                return true;
            }
            <endif>
        };
    }

    @Override
    public <WrappedTypeMap.(valueType)> accumulateValue(){
        <valueType> sum = 0;
        for(int i=0;i\<size;i++) sum+=valueList.get(i);
        return sum;
    }

    @Override
    public <WrappedTypeMap.(valueType)> accumulateDelta(){
        <valueType> sum = 0;
        for(int i=0;i\<size;i++) sum+=deltaList.get(i).<valueType>Value();
        return sum;
    }

    @Override
	public void iterate(MyVisitorImpl visitor) {
		for (int i=0; i\<size; i++) {
		    <if(IsKeyAsIndex.(keyType))>
		    if (!visitor.visit(i, valueList.get(i), deltaList.get(i).<valueType>Value()))
		        break;
		    <else>
		    <if(IsPairKey.(keyType))>
		    Pair pair = indKeyMap.get(i);
		    if (!visitor.visit(pair.toString(), valueList.get(i), deltaList.get(i).<valueType>Value()))
                break;
            <else>
            if (!visitor.visit(indKeyMap.get(i), valueList.get(i), deltaList.get(i).<valueType>Value()))
                break;
            <endif>
		    <endif>
		}
	}

    @Override
    public int getSize(){
        return size;
    }

    <if(IsPairKey.(keyType))>
    private class Pair {
        final int v0;
        final int v1;
        private int hashCode = -1;

        Pair(int v0, int v1) {
            this.v0 = v0;
            this.v1 = v1;
        }

        @Override
        public String toString() {
            return v0 + " " + v1;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Key key = (Key) o;

            if (v0 != key.v0) return false;
            return v1 == key.v1;
        }

        @Override
        public int hashCode() {
            if (hashCode != -1)
                return hashCode;
            hashCode = v0;
            hashCode = 31 * hashCode + v1;
            return hashCode;
        }
    }
    <endif>
}
>>