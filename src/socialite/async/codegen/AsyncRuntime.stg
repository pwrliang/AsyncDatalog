import "Utils.stg"
AsyncRuntime(initSize, threadNum, dynamic, checkType, checkerInterval, threshold, cond) ::= <<
package socialite.async.codegen;
<importForRuntime()>

public class AsyncRuntime extends AsyncRuntimeBase{
    private static final Log L = LogFactory.getLog(AsyncRuntime.class);
    private LocalEngine syncEngine;
    private BaseAsyncTable asyncTable;
    private static final int INIT_SIZE = <initSize>;
    private static final int THREAD_NUM = <threadNum>;
    private Worker[] workers;
    private Checker checker;

    public AsyncRuntime(LocalEngine syncEngine, TableInst[] recInstArr, TableInst[] edgeInstArr) {
        this.syncEngine = syncEngine;
        asyncTable = new AsyncTable(INIT_SIZE);
        loadData(recInstArr, edgeInstArr);
        L.info("Data Loaded size:" + asyncTable.getSize());
        createThreads();
    }

    private void loadData(TableInst[] initTableInstArr, TableInst[] edgeTableInstArr) {
        try {
            Method method;
            <if(dynamic)><!动态算法需要edge做连接，如prog4、9!>
            method = edgeTableInstArr[0].getClass().getDeclaredMethod("iterate", VisitorImpl.class);
            for (TableInst tableInst : edgeTableInstArr) {
                if (!tableInst.isEmpty()) {
                    method.invoke(tableInst, asyncTable.getEdgeVisitor());
                    //tableInst.clear();
                }
            }
            <endif>
            method = initTableInstArr[0].getClass().getDeclaredMethod("iterate", VisitorImpl.class);
            for (TableInst tableInst : initTableInstArr) {
                if (!tableInst.isEmpty()) {
                    method.invoke(tableInst, asyncTable.getInitVisitor());
                    //tableInst.clear();
                }
            }
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    private void createThreads(){
        workers = new Worker[THREAD_NUM];
        checker = new Checker();
        checker.setPriority(Thread.MAX_PRIORITY);
        arrangeTask();
    }

    private void arrangeTask() {
        int blockSize = asyncTable.getSize() / THREAD_NUM;
        if (blockSize == 0) {
            L.warn("too many threads");
            blockSize = asyncTable.getSize();
        }
        for (int tid = 0; tid \< THREAD_NUM; tid++) {
            int start = tid * blockSize;
            int end = (tid + 1) * blockSize;
            if (tid == THREAD_NUM - 1)
                end = asyncTable.getSize();
            if (workers[tid] == null) {
                workers[tid] = new Worker(tid, start, end);
            } else {
                workers[tid].start = start;
                workers[tid].end = end;
            }
        }
    }

    @Override
    public void run() {
        checker.start();
        Arrays.stream(workers).forEach(Worker::start);
        L.info("worker started");
        try {
            for (Worker worker : workers)
                worker.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        L.info("done elapsed:" + checker.stopWatch.getTime());
        L.info("checker consumed " + checkerConsume);
        L.info("checker thread exit");
        <!
        int size = 6;
        for(int i=0;i\<size;i++){
            asyncTable.updateLockFree(i);
            size = asyncTable.getSize();
        }!>
    }

    @Override
    public BaseAsyncTable getAsyncTable(){
        return asyncTable;
    }

    private class Worker extends Thread{
        int start;
        int end;
        int tid;

        private Worker(int tid, int start, int end) {
            this.tid = tid;
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            while (!checker.stop) {
                for (int k = start; k \< end; k++) {
                    asyncTable.updateLockFree(k);
                }
            }
        }

        @Override
        public String toString() {
            return String.format("id: %d range: [%d, %d)", tid, start, end);
        }
    }

    long checkerConsume;
    private class Checker extends Thread {
        private boolean stop = false;
        StopWatch stopWatch;
        private static final int CHECKER_INTERVAL = <checkerInterval>;
        StopWatch checkerSW;

        private Checker(){
            stopWatch = new StopWatch();
            checkerSW = new StopWatch();
        }

        private void done() {
            stop = true;
            stopWatch.stop();
        }

        @Override
        public void run() {
            stopWatch.start();
            while (true) {
                try {
                    checkerSW.reset();
                    checkerSW.start();
                    <if (IsCheckDelta.(checkType))>
                    double sum = 0.0d;
                    if(asyncTable.accumulateDelta() instanceof Integer)
                        sum = ((Integer)asyncTable.accumulateDelta()) + 0.0d;
                    else if(asyncTable.accumulateDelta() instanceof Long)
                        sum = ((Long)asyncTable.accumulateDelta()) + 0.0d;
                    else if(asyncTable.accumulateDelta() instanceof Float)
                        sum = ((Float)asyncTable.accumulateDelta()) + 0.0d;
                    else if(asyncTable.accumulateDelta() instanceof Double)
                        sum = ((Double)asyncTable.accumulateDelta()) + 0.0d;
                    L.info("sum of delta: " + sum);
                    if (sum <cond> <threshold>) {
                        done();
                        break;
                    }
                    <elseif(IsCheckValue.(checkType))>
                    double sum = 0.0d;
                    if(asyncTable.accumulateValue() instanceof Integer)
                        sum = ((Integer)asyncTable.accumulateValue()) + 0.0d;
                    else if(asyncTable.accumulateValue() instanceof Long)
                        sum = ((Long)asyncTable.accumulateValue()) + 0.0d;
                    else if(asyncTable.accumulateValue() instanceof Float)
                        sum = ((Float)asyncTable.accumulateValue()) + 0.0d;
                    else if(asyncTable.accumulateValue() instanceof Double)
                        sum = ((Double)asyncTable.accumulateValue()) + 0.0d;
                    L.info("sum of delta: " + sum);
                    if (sum <cond> <threshold>) {
                        done();
                        break;
                    }
                    <endif>
                    checkerSW.stop();
                    checkerConsume += checkerSW.getTime();
                    <if(dynamic)>
                    arrangeTask();
                    <endif>
                    Thread.sleep(CHECKER_INTERVAL);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
>>