import "Utils.stg"
AsyncRuntime(initSize, threadNum, dynamic, checkType, checkerInterval, threshold, cond) ::= <<
package socialite.async.codegen;
<importForRuntime()>

public class AsyncRuntime extends AsyncRuntimeBase{
    private static final Log L = LogFactory.getLog(AsyncRuntime.class);
    private LocalEngine syncEngine;
    private BaseAsyncTable asyncTable;
    private static final int INIT_SIZE = <initSize>;
    private static final int THREAD_NUM = <threadNum>;
    private Worker[] workers;
    private Checker checker;

    public AsyncRuntime(LocalEngine syncEngine, TableInst[] recInstArr, TableInst[] edgeInstArr) {
        this.syncEngine = syncEngine;
        asyncTable = new AsyncTable(INIT_SIZE);
        loadData(recInstArr, edgeInstArr);
        L.info("Data Loaded size:" + asyncTable.getSize());
        createThreads();
    }

    private void loadData(TableInst[] initTableInstArr, TableInst[] edgeTableInstArr) {
        try {
            Method method;
            <if(dynamic)><!动态算法需要edge做连接，如prog4、9!>
            method = edgeTableInstArr[0].getClass().getDeclaredMethod("iterate", VisitorImpl.class);
            for (TableInst tableInst : edgeTableInstArr) {
                if (!tableInst.isEmpty()) {
                    method.invoke(tableInst, asyncTable.getEdgeVisitor());
                    //tableInst.clear();
                }
            }
            <endif>
            method = initTableInstArr[0].getClass().getDeclaredMethod("iterate", VisitorImpl.class);
            for (TableInst tableInst : initTableInstArr) {
                if (!tableInst.isEmpty()) {
                    method.invoke(tableInst, asyncTable.getInitVisitor());
                    //tableInst.clear();
                }
            }
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    private void createThreads(){
        workers = new Worker[THREAD_NUM];
        checker = new Checker();
        checker.setPriority(Thread.MAX_PRIORITY);
        arrangeTask();
    }

    private void arrangeTask() {
        int blockSize = asyncTable.getSize() / THREAD_NUM;
        if (blockSize == 0) {
            System.err.println("too many threads");
            System.exit(0);
        }
        for (int tid = 0; tid \< THREAD_NUM; tid++) {
            int start = tid * blockSize;
            int end = (tid + 1) * blockSize;
            if (tid == THREAD_NUM - 1)
                end = asyncTable.getSize();
            if (workers[tid] == null) {
                workers[tid] = new Worker(tid, start, end);
            } else {
                workers[tid].start = start;
                workers[tid].end = end;
            }
        }
    }

    @Override
    public void run() {
        checker.start();
        Arrays.stream(workers).forEach(Worker::start);
        L.info("worker started");
        checker.stopWatch.start();
        try {
            for (Worker worker : workers)
                worker.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        L.info("done elapsed:" + checker.stopWatch.getTime());
        L.info("checker consumed " + checkerConsume);
        L.info("checker thread exit");
    }

    @Override
    public BaseAsyncTable getAsyncTable(){
        return asyncTable;
    }

    private class Worker extends Thread {
        int start;
        int end;
        int tid;

        private Worker(int tid, int start, int end) {
            this.tid = tid;
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            while (!checker.stop) {
                for (int k = start; k \< end; k++) {
                    asyncTable.updateLockFree(k);
                }
            }
        }

        @Override
        public String toString() {
            return String.format("id: %d range: [%d, %d)", tid, start, end);
        }
    }

    long checkerConsume;
    private class Checker extends Thread {
        private boolean stop = false;
        StopWatch stopWatch;
        private static final int CHECKER_INTERVAL = <checkerInterval>;
        StopWatch checkerSW;

        private Checker(){
            stopWatch = new StopWatch();
            checkerSW = new StopWatch();
        }

        private void done() {
            stop = true;
            stopWatch.stop();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    checkerSW.reset();
                    checkerSW.start();
                    <if (IsCheckDelta.(checkType))>
                    double sum = (double)asyncTable.accumulateDelta(); //统一使用double，防止溢出
                    L.info("sum of delta: " + sum);
                    if (sum <cond> <threshold>) {
                        done();
                        break;
                    }
                    <elseif(IsCheckValue.(checkType))>
                    double sum = (double)asyncTable.accumulateValue();
                    if (sum <cond> <threshold>) {
                        done();
                        break;
                    }
                    <endif>
                    checkerSW.stop();
                    checkerConsume += checkerSW.getTime();
                    <if(dynamic)>
                    arrangeTask();
                    <endif>
                    Thread.sleep(CHECKER_INTERVAL);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
>>